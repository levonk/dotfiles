# app/infra/logging/logger.py
# Generated by feature: logging-single-chokepoint@v1

from __future__ import annotations
import json
import sys
from datetime import datetime
from typing import Literal, Dict, Any

LogLevel = Literal['debug', 'info', 'warn', 'error']

_level_order: Dict[LogLevel, int] = {
    'debug': 10,
    'info': 20,
    'warn': 30,
    'error': 40,
}

_current_level: LogLevel = 'info'

def set_level(level: LogLevel) -> None:
    global _current_level
    _current_level = level

def _enabled(level: LogLevel) -> bool:
    return _level_order[level] >= _level_order[_current_level]

def log(level: LogLevel, message: str, **ctx: Any) -> None:
    if not _enabled(level):
        return
    record = {
        'ts': datetime.utcnow().isoformat() + 'Z',
        'level': level,
        'message': message,
        **ctx,
    }
    sys.stdout.write(json.dumps(record) + "\n")

class Logger:
    def debug(self, m: str, **ctx: Any) -> None: log('debug', m, **ctx)
    def info(self, m: str, **ctx: Any) -> None: log('info', m, **ctx)
    def warn(self, m: str, **ctx: Any) -> None: log('warn', m, **ctx)
    def error(self, m: str, **ctx: Any) -> None: log('error', m, **ctx)
    def set_level(self, level: LogLevel) -> None: set_level(level)

logger = Logger()
