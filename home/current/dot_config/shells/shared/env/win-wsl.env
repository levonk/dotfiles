#!/usr/bin/env sh
# shellcheck shell=sh
#{{- includeTemplate "dot_config/ai/templates/shell/sourceable.sh.tmpl" (dict "path" .path "name" .name) -}}


# =====================================================================

# WSL Path Cleanup: Remove Windows paths while preserving essential ones
# Multiple strategies for robust path cleaning

# Strategy 1: Pattern-based filtering (most flexible)
_clean_wsl_paths() {
  # Define patterns for paths to remove (Windows-specific)
  local remove_patterns="/mnt/[c-z]/ /c/ /d/ /e/ /f/ C:\\\\ D:\\\\ E:\\\\ F:\\\\"

  # Define patterns for paths to keep (WSL/Linux specific or explicitly needed)
  local keep_patterns="/usr/ /bin/ /sbin/ /lib/ /opt/ /home/ /root/ /tmp/ /var/ /dev/ /proc/ /sys/"

  # Split PATH into individual paths
  local old_ifs="$IFS"
  IFS=':'
  local new_path=""
  local path_kept=""

  for path in $PATH; do
    # Skip empty paths
    [ -z "$path" ] && continue

    # Check if path should be kept
    local should_keep=""
    for keep_pattern in $keep_patterns; do
      case "$path" in
        $keep_pattern*) should_keep="1"; break ;;
      esac
    done

    # If not in keep patterns, check if it should be removed
    if [ -z "$should_keep" ]; then
      for remove_pattern in $remove_patterns; do
        case "$path" in
          $remove_pattern*) continue 2 ;; # Skip this path
        esac
      done
    fi

    # Additional checks: skip non-existent or inaccessible paths
    if [ -e "$path" ] || [ -d "$path" ]; then
      # Path exists or is a directory, keep it
      if [ -n "$new_path" ]; then
        new_path="$new_path:$path"
        path_kept="$path_kept, $path"
      else
        new_path="$path"
        path_kept="$path"
      fi
    fi
  done

  IFS="$old_ifs"

  if [ -n "$new_path" ]; then
    export PATH="$new_path"
    # Optional: log kept paths for debugging (uncomment if needed)
    # printf "WSL: Kept paths: %s\n" "$path_kept" >&2
  fi
}

# Strategy 2: Simple existence check (most conservative)
_clean_wsl_paths_conservative() {
  local old_ifs="$IFS"
  IFS=':'
  local new_path=""

  for path in $PATH; do
    [ -z "$path" ] && continue

    # Only keep paths that actually exist and are accessible
    if [ -d "$path" ] && [ -r "$path" ]; then
      if [ -n "$new_path" ]; then
        new_path="$new_path:$path"
      else
        new_path="$path"
      fi
    fi
  done

  IFS="$old_ifs"

  if [ -n "$new_path" ]; then
    export PATH="$new_path"
  fi
}

# Strategy 3: Environment-based filtering (most maintainable)
_clean_wsl_paths_env() {
  # Define essential Windows paths to keep (if any)
  local essential_win_paths=""

  local old_ifs="$IFS"
  IFS=':'
  local new_path=""

  for path in $PATH; do
    [ -z "$path" ] && continue

    # Check if path is in essential list (if defined)
    local is_essential=""
    if [ -n "$essential_win_paths" ]; then
      for essential in $essential_win_paths; do
        [ "$path" = "$essential" ] && is_essential="1" && break
      done
    fi

    # Keep Linux/WSL paths and essential Windows paths
    case "$path" in
      /usr/*|/bin/*|/sbin/*|/lib/*|/opt/*|/home/*|/root/*|/tmp/*|/var/*|/dev/*|/proc/*|/sys/*)
        if [ -d "$path" ]; then
          if [ -n "$new_path" ]; then
            new_path="$new_path:$path"
          else
            new_path="$path"
          fi
        fi
        ;;
      *)
        # Check if it's an essential Windows path
        if [ -n "$is_essential" ] && [ -d "$path" ]; then
          if [ -n "$new_path" ]; then
            new_path="$new_path:$path"
          else
            new_path="$path"
          fi
        fi
        ;;
    esac
  done

  IFS="$old_ifs"

  if [ -n "$new_path" ]; then
    export PATH="$new_path"
  fi
}

# Run cleanup (choose one strategy)
# _clean_wsl_paths  # Most flexible - uses patterns
_clean_wsl_paths_conservative  # Most conservative - only keeps existing directories
# _clean_wsl_paths_env  # Most maintainable - uses environment variables
