#!/usr/bin/env sh
# shellcheck shell=sh
#{{- includeTemplate "dot_config/ai/templates/shell/sourceable.sh.tmpl" (dict "path" .path "name" .name) -}}


# WSL Detection: Only run on actual WSL environments
_is_wsl() {
  # Method 1: Check /proc/version for WSL indicators
  if [ -f "/proc/version" ]; then
    if grep -q -i "microsoft\|wsl" "/proc/version" 2>/dev/null; then
      return 0
    fi
  fi

  # Method 2: Check /proc/sys/kernel/osrelease
  if [ -f "/proc/sys/kernel/osrelease" ]; then
    if grep -q -i "wsl" "/proc/sys/kernel/osrelease" 2>/dev/null; then
      return 0
    fi
  fi

  # Method 3: Check for WSL-specific environment variables
  if [ -n "${WSL_DISTRO_NAME:-}" ] || [ -n "${WSLENV:-}" ]; then
    return 0
  fi

  # Method 4: Check if running under Windows Subsystem for Linux
  if command -v uname >/dev/null 2>&1; then
    case "$(uname -a)" in
      *Microsoft*|*microsoft*) return 0 ;;
      *WSL*|*wsl*) return 0 ;;
    esac
  fi

  return 1 # Not WSL
}

# Early exit if not on WSL
if ! _is_wsl; then
  return 0 2>/dev/null || exit 0
fi

# WSL Path Cleanup: Remove Windows paths while preserving essential ones
# Multiple strategies for robust path cleaning
#
# This script automatically detects WSL environments using multiple methods:
# - /proc/version contains "Microsoft" or "WSL"
# - /proc/sys/kernel/osrelease contains "WSL"
# - WSL-specific environment variables (WSL_DISTRO_NAME, WSLENV)
# - uname output contains "Microsoft" or "WSL"
#
# Uses chezmoi template system for cross-platform compatibility.
# Only runs on actual WSL systems, exits early on regular Windows/Linux.

# Strategy 1: Pattern-based filtering (most flexible)
_clean_wsl_paths() {
  # Define patterns for paths to remove (Windows-specific)
  local remove_patterns="/mnt/[c-z]/ /c/ /d/ /e/ /f/ C:\\\\ D:\\\\ E:\\\\ F:\\\\"

  # Define patterns for paths to keep (WSL/Linux specific or explicitly needed)
  local keep_patterns="/usr/ /bin/ /sbin/ /lib/ /opt/ /home/ /root/ /tmp/ /var/ /dev/ /proc/ /sys/"

  # Split PATH into individual paths
  local old_ifs="$IFS"
  IFS=':'
  local new_path=""
  local path_kept=""

  for path in $PATH; do
    # Skip empty paths
    [ -z "$path" ] && continue

    # Check if path should be kept
    local should_keep=""
    for keep_pattern in $keep_patterns; do
      case "$path" in
        $keep_pattern*) should_keep="1"; break ;;
      esac
    done

    # If not in keep patterns, check if it should be removed
    if [ -z "$should_keep" ]; then
      for remove_pattern in $remove_patterns; do
        case "$path" in
          $remove_pattern*) continue 2 ;; # Skip this path
        esac
      done
    fi

    # Additional checks: skip non-existent or inaccessible paths
    if [ -e "$path" ] || [ -d "$path" ]; then
      # Path exists or is a directory, keep it
      if [ -n "$new_path" ]; then
        new_path="$new_path:$path"
        path_kept="$path_kept, $path"
      else
        new_path="$path"
        path_kept="$path"
      fi
    fi
  done

  IFS="$old_ifs"

  if [ -n "$new_path" ]; then
    export PATH="$new_path"
    # Optional: log kept paths for debugging (uncomment if needed)
    # printf "WSL: Kept paths: %s\n" "$path_kept" >&2
  fi
}

# Strategy 2: Simple existence check (most conservative)
_clean_wsl_paths_conservative() {
  local old_ifs="$IFS"
  IFS=':'
  local new_path=""

  for path in $PATH; do
    [ -z "$path" ] && continue

    # Only keep paths that actually exist and are accessible
    if [ -d "$path" ] && [ -r "$path" ]; then
      if [ -n "$new_path" ]; then
        new_path="$new_path:$path"
      else
        new_path="$path"
      fi
    fi
  done

  IFS="$old_ifs"

  if [ -n "$new_path" ]; then
    export PATH="$new_path"
  fi
}

_clean_wsl_paths_env() {
  # Define essential Windows paths to keep (if any)
  local essential_win_paths=""

  local old_ifs="$IFS"
    # Keep Linux/WSL paths and essential Windows paths
    case "$path" in
      /usr/*|/bin/*|/sbin/*|/lib/*|/opt/*|/home/*|/root/*|/tmp/*|/var/*|/dev/*|/proc/*|/sys/*)
        if [ -d "$path" ]; then
          if [ -n "$new_path" ]; then
            new_path="$new_path:$path"
          else
            new_path="$path"
          fi
        fi
        ;;
      *)
        # Check if it's an essential Windows path
        if [ -n "$is_essential" ] && [ -d "$path" ]; then
          if [ -n "$new_path" ]; then
            new_path="$new_path:$path"
          else
            new_path="$path"
          fi
        fi
        ;;
    esac
  done

  IFS="$old_ifs"

  if [ -n "$new_path" ]; then
    export PATH="$new_path"
  fi
}

# Run cleanup (choose one strategy)
# _clean_wsl_paths  # Most flexible - uses patterns
_clean_wsl_paths_conservative  # Most conservative - only keeps existing directories
# _clean_wsl_paths_env  # Most maintainable - uses environment variables
