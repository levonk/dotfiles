#!/usr/bin/env bash
{{ if and (ne .chezmoi.os "windows") (ne .chezmoi.os "unknown") }}
# Cross-platform package installer (Unix)
# Runs once via chezmoi. Installs shared and OS-specific packages using the
# available package manager. Best-effort, idempotent as much as the PM allows.
#
# Controls:
#   CHEZMOI_INSTALL_PKGS=1   -> enable (default 1)
#   CHEZMOI_PKGS_STRICT=1    -> treat failures as fatal
#   CHEZMOI_PKGS_DRY_RUN=1   -> print actions only, no changes
#   CHEZMOI_PKGS_SUDO=0      -> do not use sudo even if not root
#
set -euo pipefail

: "${CHEZMOI_INSTALL_PKGS:=1}"
: "${CHEZMOI_PKGS_STRICT:=0}"
: "${CHEZMOI_PKGS_DRY_RUN:=0}"
: "${CHEZMOI_PKGS_SUDO:=1}"

if [[ "$CHEZMOI_INSTALL_PKGS" != "1" ]]; then
  exit 0
fi

# --------------------
# Define package lists
# --------------------
# Edit these lists as needed. Package names must match your PM.
SHARED_PACKAGES=(
  git
  curl
  wget
  zsh
  neovim
  bat
  ripgrep
  direnv
  fd
  fzf
  mosh
  zoxide
  jq
  tmux
)

DEBIAN_PACKAGES=(
  build-essential
  ca-certificates
)

FEDORA_PACKAGES=(
  @development-tools
  ca-certificates
)

ARCH_PACKAGES=(
  base-devel
  ca-certificates
)

ALPINE_PACKAGES=(
  build-base
  ca-certificates
)

OPENSUSE_PACKAGES=(
  patterns-devel-base-devel_basis
  ca-certificates
)

DARWIN_PACKAGES=(
  git
)

# Optional denormalized per-distro shared lists. If non-empty, these will be
# used instead of SHARED_PACKAGES for that distro to account for naming
# differences (e.g., Debian fd-find vs fd, bat vs batcat binary name, etc.).
DEBIAN_SHARED_PACKAGES=(
  git
  curl
  wget
  zsh
  neovim
  bat
  ripgrep
  fd-find
  fzf
  mosh
  zoxide
  jq
  tmux
)

FEDORA_SHARED_PACKAGES=()
ARCH_SHARED_PACKAGES=()
ALPINE_SHARED_PACKAGES=()
OPENSUSE_SHARED_PACKAGES=()
DARWIN_SHARED_PACKAGES=()

# --------------------
# Helpers
# --------------------
log() { printf '%s\n' "$*"; }
warn() { printf '[WARN] %s\n' "$*" >&2; }
fail() { printf '[ERROR] %s\n' "$*" >&2; exit 1; }

need_sudo() {
  if [[ $(id -u) -ne 0 && "$CHEZMOI_PKGS_SUDO" == "1" && -x "$(command -v sudo || true)" ]]; then
    echo sudo
  else
    echo
  fi
}

run() {
  if [[ "$CHEZMOI_PKGS_DRY_RUN" == "1" ]]; then
    echo "+ $*"
    return 0
  fi
  "$@"
}

# Given a list of package names, return only those that are not yet installed.
filter_missing_packages() {
    local -n packages_to_check=$1
    local -n missing_packages_out=$2
    missing_packages_out=()

    # Map package names to the command/binary they provide.
    # This is necessary because package names (e.g., 'fd-find') do not always
    # match the command name (e.g., 'fd').
    declare -A pkg_to_cmd_map
    pkg_to_cmd_map=( 
        ["fd-find"]="fd" \
        # On Debian/Ubuntu, the 'bat' package installs the binary as 'batcat'
        # to avoid a name conflict with another tool. We check for 'batcat' first,
        # but fall back to 'bat' for other systems.
        ["bat"]="batcat" 
    )

    for pkg in "${packages_to_check[@]}"; do
        # Use the mapped command name if it exists, otherwise default to the package name.
        local cmd_name="${pkg_to_cmd_map[$pkg]:-$pkg}"
        
        # For package groups like '@development-tools' on Fedora, we can't
        # check for a single command. We'll assume they need to be installed.
        if [[ "$pkg" == "@"* ]]; then
            missing_packages_out+=("$pkg")
            continue
        fi

        # Special handling for bat -> batcat
        if [[ "$pkg" == "bat" ]] && command -v batcat >/dev/null 2>&1; then
            log "[chezmoi] Package 'bat' (as 'batcat') is already installed."
            continue
        fi

        if ! command -v "$cmd_name" >/dev/null 2>&1; then
            missing_packages_out+=("$pkg")
        else
            log "[chezmoi] Package '$pkg' providing '$cmd_name' is already installed."
        fi
    done
}

# --------------------
# Detect PM and install
# --------------------
SUDO=$(need_sudo)
OS="{{ .chezmoi.os }}"

# Select correct package lists for the OS
final_packages=()
case "$OS" in
  linux)
    # Debian/Ubuntu
    if command -v apt-get >/dev/null 2>&1; then
        if [[ ${#DEBIAN_SHARED_PACKAGES[@]} -gt 0 ]]; then final_packages+=("${DEBIAN_SHARED_PACKAGES[@]}"); else final_packages+=("${SHARED_PACKAGES[@]}"); fi
        final_packages+=("${DEBIAN_PACKAGES[@]}")
        filter_missing_packages final_packages packages_to_install
        if [ ${#packages_to_install[@]} -gt 0 ]; then
            log "Installing packages with apt-get: ${packages_to_install[*]}"
            run $SUDO apt-get update -y
            run $SUDO apt-get install -y "${packages_to_install[@]}"
        else
            log "All apt-get packages are already installed."
        fi
    # Fedora/RHEL
    elif command -v dnf >/dev/null 2>&1 || command -v yum >/dev/null 2>&1; then
        PM="dnf"
        if command -v yum >/dev/null 2>&1 && ! command -v dnf >/dev/null 2>&1; then PM="yum"; fi
        if [[ ${#FEDORA_SHARED_PACKAGES[@]} -gt 0 ]]; then final_packages+=("${FEDORA_SHARED_PACKAGES[@]}"); else final_packages+=("${SHARED_PACKAGES[@]}"); fi
        final_packages+=("${FEDORA_PACKAGES[@]}")
        filter_missing_packages final_packages packages_to_install
        if [ ${#packages_to_install[@]} -gt 0 ]; then
            log "Installing packages with $PM: ${packages_to_install[*]}"
            run $SUDO $PM install -y "${packages_to_install[@]}"
        else
            log "All $PM packages are already installed."
        fi
    # Arch
    elif command -v pacman >/dev/null 2>&1; then
        if [[ ${#ARCH_SHARED_PACKAGES[@]} -gt 0 ]]; then final_packages+=("${ARCH_SHARED_PACKAGES[@]}"); else final_packages+=("${SHARED_PACKAGES[@]}"); fi
        final_packages+=("${ARCH_PACKAGES[@]}")
        # pacman's --needed flag handles this check for us
        packages_to_install=("${final_packages[@]}")
        log "Installing packages with pacman: ${packages_to_install[*]}"
        run $SUDO pacman -Sy --needed --noconfirm "${packages_to_install[@]}"
    # Alpine
    elif command -v apk >/dev/null 2>&1; then
        if [[ ${#ALPINE_SHARED_PACKAGES[@]} -gt 0 ]]; then final_packages+=("${ALPINE_SHARED_PACKAGES[@]}"); else final_packages+=("${SHARED_PACKAGES[@]}"); fi
        final_packages+=("${ALPINE_PACKAGES[@]}")
        filter_missing_packages final_packages packages_to_install
        if [ ${#packages_to_install[@]} -gt 0 ]; then
            log "Installing packages with apk: ${packages_to_install[*]}"
            run $SUDO apk add --no-cache "${packages_to_install[@]}"
        else
            log "All apk packages are already installed."
        fi
    # OpenSUSE
    elif command -v zypper >/dev/null 2>&1; then
        if [[ ${#OPENSUSE_SHARED_PACKAGES[@]} -gt 0 ]]; then final_packages+=("${OPENSUSE_SHARED_PACKAGES[@]}"); else final_packages+=("${SHARED_PACKAGES[@]}"); fi
        final_packages+=("${OPENSUSE_PACKAGES[@]}")
        filter_missing_packages final_packages packages_to_install
        if [ ${#packages_to_install[@]} -gt 0 ]; then
            log "Installing packages with zypper: ${packages_to_install[*]}"
            run $SUDO zypper -n install "${packages_to_install[@]}"
        else
            log "All zypper packages are already installed."
        fi
    else
        warn "No supported package manager found for Linux."
        [[ "$CHEZMOI_PKGS_STRICT" == "1" ]] && exit 1
    fi
    ;;
  darwin)
    if command -v brew >/dev/null 2>&1; then
        if [[ ${#DARWIN_SHARED_PACKAGES[@]} -gt 0 ]]; then final_packages+=("${DARWIN_SHARED_PACKAGES[@]}"); else final_packages+=("${SHARED_PACKAGES[@]}"); fi
        final_packages+=("${DARWIN_PACKAGES[@]}")
        filter_missing_packages final_packages packages_to_install
        if [ ${#packages_to_install[@]} -gt 0 ]; then
            log "Installing packages with Homebrew: ${packages_to_install[*]}"
            run brew update
            run brew install "${packages_to_install[@]}"
        else
            log "All Homebrew packages are already installed."
        fi
    else
        warn "Homebrew not found. Install from https://brew.sh and re-run."
        [[ "$CHEZMOI_PKGS_STRICT" == "1" ]] && exit 1
    fi
    ;;
  *)
    warn "Unsupported OS in Unix installer: $OS"
    [[ "$CHEZMOI_PKGS_STRICT" == "1" ]] && exit 1
    ;;
esac

#############################################
# Developer tools via mise (bun, bats, etc.)
#############################################

# Ensure mise exists; install to ~/.local/bin if missing (non-fatal on failure)
ensure_mise() {
  if command -v mise >/dev/null 2>&1; then
    return 0
  fi
  log "mise not found; attempting install"
  INSTALLER_URL="https://mise.jdx.dev/install.sh"
  if command -v curl >/dev/null 2>&1; then
    if [[ "$CHEZMOI_PKGS_DRY_RUN" == "1" ]]; then
      echo "+ curl -fsSL $INSTALLER_URL | sh";
    else
      curl -fsSL "$INSTALLER_URL" | sh || warn "Failed to install mise via curl"
    fi
  elif command -v wget >/dev/null 2>&1; then
    if [[ "$CHEZMOI_PKGS_DRY_RUN" == "1" ]]; then
      echo "+ wget -qO- $INSTALLER_URL | sh";
    else
      wget -qO- "$INSTALLER_URL" | sh || warn "Failed to install mise via wget"
    fi
  else
    warn "Neither curl nor wget available to install mise"
  fi
}

# Initialize mise env in this shell if possible (don’t fail hard if it can’t)
init_mise_env() {
  if command -v mise >/dev/null 2>&1; then
    # shellcheck disable=SC1090
    eval "$(mise env -s bash 2>/dev/null)" || true
  fi
}

# Ensure a mise plugin and install a tool if not present
ensure_mise_tool() {
  local plugin="$1" version_spec="${2:-latest}"
  if ! mise plugins | awk '{print $1}' | grep -qx "$plugin" 2>/dev/null; then
    run mise plugins add "$plugin" || warn "Failed adding mise plugin: $plugin"
  fi
  # Install and set as global (idempotent)
  run mise install "${plugin}@${version_spec}" || warn "mise install failed: ${plugin}@${version_spec}"
  run mise use -g "${plugin}@${version_spec}" || true
}

# Ensure bun is available for bunx usage
ensure_bun() {
  if command -v bun >/dev/null 2>&1; then
    return 0
  fi
  if command -v mise >/dev/null 2>&1; then
    log "Installing bun via mise"
    ensure_mise_tool bun latest
  else
    warn "mise not available; cannot ensure bun"
  fi
}

# Ensure bats is available; prefer native binary from mise, else shim via bunx
ensure_bats() {
  if command -v bats >/dev/null 2>&1; then
    return 0
  fi
  if command -v mise >/dev/null 2>&1; then
    log "Installing bats via mise"
    ensure_mise_tool bats latest
  fi
  if ! command -v bats >/dev/null 2>&1; then
    # Fallback shim using bunx so `bats` works even without a global install
    ensure_bun
    local shim="$HOME/.local/bin/bats"
    mkdir -p "$(dirname "$shim")"
    if [[ ! -f "$shim" ]]; then
      if [[ "$CHEZMOI_PKGS_DRY_RUN" == "1" ]]; then
        echo "+ create bats shim at $shim (bunx)"
      else
        cat > "$shim" <<'EOSH'
#!/usr/bin/env bash
set -euo pipefail
exec bunx --silent bats "$@"
EOSH
        chmod +x "$shim" || true
        log "Installed bats shim using bunx at $shim"
      fi
    fi
  fi
}

# Perform tool bootstrap
ensure_mise
init_mise_env
if command -v mise >/dev/null 2>&1; then
  ensure_bun
  ensure_bats
else
  warn "Skipping mise-managed tools since mise is unavailable"
fi

log "Package installation step completed."
exit 0
{{ end }}
