#!/usr/bin/env bash
# Validate SSH security configuration and warn about potential risks
# This script runs after chezmoi applies SSH configurations

set -euo pipefail

SSH_CONFIG="$HOME/.ssh/config"
# shellcheck disable=SC2034  # KNOWN_HOSTS reserved for future use
KNOWN_HOSTS="$HOME/.ssh/known_hosts"

# Show how to run this script manually
SCRIPT_PATH="$HOME/.chezmoiscripts/validate-ssh-security.sh"
echo "üîß Run manually: $SCRIPT_PATH"

echo "üîí SSH Security Validation"
echo "=========================="

# Check if SSH config exists
if [[ ! -f "$SSH_CONFIG" ]]; then
    echo "‚ùå SSH config not found at $SSH_CONFIG"
    exit 1
fi

echo "‚úÖ SSH config found at $SSH_CONFIG"

# Function to check SSH configuration security
check_ssh_security() {
    local issues=0

    echo ""
    echo "üîç Checking SSH security configuration..."

    # Check for Protocol 2
    if ! grep -q "Protocol 2" "$SSH_CONFIG"; then
        echo "‚ö†Ô∏è  WARNING: SSH Protocol version not explicitly set to 2"
        echo "   Risk: May allow insecure SSH protocol version 1"
        ((issues++))
    else
        echo "‚úÖ SSH Protocol 2 enforced"
    fi

    # Check for secure ciphers
    if grep -q "Ciphers.*chacha20-poly1305" "$SSH_CONFIG"; then
        echo "‚úÖ Modern ciphers configured (ChaCha20-Poly1305)"
    else
        echo "‚ö†Ô∏è  WARNING: Modern ciphers not found in configuration"
        echo "   Risk: May use weaker encryption algorithms"
        ((issues++))
    fi

    # Check for secure MACs
    if grep -q "MACs.*hmac-sha2" "$SSH_CONFIG"; then
        echo "‚úÖ Secure MAC algorithms configured"
    else
        echo "‚ö†Ô∏è  WARNING: Secure MAC algorithms not configured"
        echo "   Risk: May use weaker message authentication"
        ((issues++))
    fi

    # Check for secure key exchange
    if grep -q "KexAlgorithms.*curve25519" "$SSH_CONFIG"; then
        echo "‚úÖ Secure key exchange algorithms configured (Curve25519)"
    else
        echo "‚ö†Ô∏è  WARNING: Secure key exchange algorithms not found"
        echo "   Risk: May use weaker key exchange methods"
        ((issues++))
    fi

    # Check for Ed25519 host keys
    if grep -q "HostKeyAlgorithms.*ssh-ed25519" "$SSH_CONFIG"; then
        echo "‚úÖ Ed25519 host key algorithms preferred"
    else
        echo "‚ö†Ô∏è  WARNING: Ed25519 host key algorithms not prioritized"
        echo "   Risk: May use weaker host key algorithms"
        ((issues++))
    fi

    # Check for agent forwarding disabled
    if grep -q "ForwardAgent no" "$SSH_CONFIG"; then
        echo "‚úÖ SSH agent forwarding disabled (secure)"
    else
        echo "‚ö†Ô∏è  WARNING: SSH agent forwarding not explicitly disabled"
        echo "   Risk: Potential agent forwarding attacks"
        ((issues++))
    fi

    # Check for X11 forwarding disabled
    if grep -q "ForwardX11 no" "$SSH_CONFIG"; then
        echo "‚úÖ X11 forwarding disabled (secure)"
    else
        echo "‚ö†Ô∏è  WARNING: X11 forwarding not explicitly disabled"
        echo "   Risk: Potential X11 forwarding vulnerabilities"
        ((issues++))
    fi

    # Check for strict host key checking
    if grep -q "StrictHostKeyChecking" "$SSH_CONFIG"; then
        echo "‚úÖ Host key checking configured"
    else
        echo "‚ö†Ô∏è  WARNING: Host key checking not configured"
        echo "   Risk: Vulnerable to man-in-the-middle attacks"
        ((issues++))
    fi

    return $issues
}

# Function to test SSH connection security
test_ssh_connections() {
    echo ""
    echo "üß™ Testing SSH connections to VCS providers..."

    local hosts=("github.com" "gitlab.com" "bitbucket.org" "codeberg.org")

    for host in "${hosts[@]}"; do
        echo -n "Testing $host: "

        # Run once, then classify by message content (SSH to VCS often returns non-zero even on success)
        output=$(timeout 10 ssh -T \
            -o ConnectTimeout=5 \
            -o BatchMode=yes \
            -o PasswordAuthentication=no \
            -o KbdInteractiveAuthentication=no \
            -o PreferredAuthentications=publickey \
            -o IdentitiesOnly=yes \
            "git@$host" 2>&1 || true)
        if echo "$output" | grep -qiE "you'?ve successfully authenticated|successfully authenticated|authenticated via ssh key|shell access is disabled"; then
            echo "‚úÖ Connected successfully"
        elif echo "$output" | grep -qiE "permission denied"; then
            echo "‚úÖ Host reachable (authentication expected to fail)"
        else
            echo "‚ö†Ô∏è  Connection failed or timeout"
        fi
    done
}

# Function to check for weak SSH keys
check_ssh_keys() {
    echo ""
    echo "üîë Checking SSH key security..."

    local weak_keys=0

    # Enumerate private keys in ~/.ssh (exclude public keys and non-key files)
    shopt -s nullglob
    local sshdir="$HOME/.ssh"
    local skip_names=(config known_hosts authorized_keys known_hosts.old)
    for key in "$sshdir"/*; do
        # Skip directories and .pub files
        [[ -f "$key" ]] || continue
        [[ "$key" == *.pub ]] && continue
        # Skip known non-key filenames
        bn="$(basename "$key")"
        for s in "${skip_names[@]}"; do
            [[ "$bn" == "$s" ]] && continue 2
        done

        # Try to get public line: prefer .pub, else derive from private key
        local publine=""
        if [[ -f "$key.pub" ]]; then
            publine="$(head -n1 "$key.pub" 2>/dev/null || true)"
        fi
        if [[ -z "$publine" ]]; then
            # Derive public key non-interactively; if encrypted, this will fail quietly
            publine="$(SSH_ASKPASS=/bin/false SSH_ASKPASS_REQUIRE=force setsid -w ssh-keygen -y -f "$key" </dev/null 2>/dev/null | head -n1 || true)"
        fi
        if [[ -z "$publine" ]]; then
            echo "‚ùì $(basename "$key"): Unknown type (unreadable or unsupported)"
            ((weak_keys++))
            continue
        fi

        local ktype
        ktype="$(printf '%s\n' "$publine" | awk '{print $1}')"
        case "$ktype" in
            ssh-ed25519)
                echo "‚úÖ $(basename "$key"): Ed25519 (preferred)"
                ;;
            sk-ssh-ed25519@openssh.com)
                echo "‚úÖ $(basename "$key"): Ed25519 FIDO/U2F (hardware-backed)"
                ;;
            ssh-rsa)
                echo "‚ö†Ô∏è  $(basename "$key"): RSA (legacy)"
                ((weak_keys++))
                ;;
            *)
                echo "‚ùì $(basename "$key"): Unknown type ($ktype)"
                ((weak_keys++))
                ;;
        esac
    done

    return $weak_keys
}

# Run security checks (do not let -e exit on expected non-zero from checks)
check_ssh_security || true
config_issues=$?

check_ssh_keys || true
weak_keys=$?

test_ssh_connections || true

# Summary
echo ""
echo "üìä Security Summary"
echo "==================="
echo "Configuration issues: $config_issues"
echo "Weak keys found: $weak_keys"

if [[ $config_issues -eq 0 && $weak_keys -eq 0 ]]; then
    echo "üéâ SSH configuration is secure!"
else
    echo "‚ö†Ô∏è  Security improvements recommended"
    echo ""
    echo "üí° To improve security:"
    echo "   1. Run 'chezmoi apply' to update SSH configuration"
    echo "   2. Regenerate weak SSH keys with Ed25519: ssh-keygen -t ed25519"
    echo "   3. Update VCS provider accounts with new public keys"
fi

# Strictness: only fail the run when SSH_VALIDATE_STRICT=1
STRICT_MODE="${SSH_VALIDATE_STRICT:-0}"
if [[ "$STRICT_MODE" == "1" ]]; then
    if [[ $config_issues -gt 0 || $weak_keys -gt 0 ]]; then
        exit 1
    else
        exit 0
    fi
else
    if [[ $config_issues -gt 0 || $weak_keys -gt 0 ]]; then
        echo ""
        echo "‚ÑπÔ∏è  Non-strict mode: not failing the run. Set SSH_VALIDATE_STRICT=1 to enforce failures."
    fi
    exit 0
fi
